# ============================================================================
# Runtime Build Files ConfigMap
# ============================================================================
# Contains all Dockerfiles and runtime source files needed to build
# compiler and runtime images inside the DinD sidecar
# ============================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: runtime-build-files
  namespace: nimbus
data:
  # Rust WASM Compiler Dockerfile
  Dockerfile.rust-wasm-compiler: |
    FROM rust:1.75-slim
    RUN rustup target add wasm32-unknown-unknown
    WORKDIR /work

  # Python Runtime
  Dockerfile.python3.11: |
    FROM python:3.11-alpine
    RUN adduser -D func || true
    WORKDIR /app
    COPY runtime-python.py /app/runtime.py
    USER func
    ENTRYPOINT ["python3", "/app/runtime.py"]

  runtime-python.py: |
    #!/usr/bin/env python3
    """
    Function runtime for Python 3.11
    Reads function code and payload from stdin, executes, outputs result to stdout.
    """
    import sys
    import json
    import traceback

    def main():
        try:
            # Read input from stdin
            input_data = json.loads(sys.stdin.read())

            handler_path = input_data.get('handler', 'handler')
            code = input_data.get('code', '')
            payload = input_data.get('payload', {})
            env_vars = input_data.get('env', {})

            # Set environment variables
            import os
            for key, value in env_vars.items():
                os.environ[key] = value

            # Parse handler (module.function format)
            if '.' in handler_path:
                module_name, func_name = handler_path.rsplit('.', 1)
            else:
                module_name, func_name = 'handler', handler_path

            # Create a namespace and execute the code
            namespace = {}
            exec(code, namespace)

            # Get the handler function
            if func_name not in namespace:
                raise ValueError(f"Handler function '{func_name}' not found in code")

            handler = namespace[func_name]

            # Create a simple context object
            class Context:
                def __init__(self):
                    self.function_name = os.environ.get('FUNCTION_NAME', 'unknown')
                    self.memory_limit_in_mb = int(os.environ.get('FUNCTION_MEMORY_MB', '256'))
                    self.function_version = os.environ.get('FUNCTION_VERSION', '$LATEST')
                    self.aws_request_id = 'uuid-placeholder'
                    self.log_group_name = '/aws/lambda/' + self.function_name
                    self.log_stream_name = 'date/[$LATEST]uuid'

            # Execute the handler
            result = handler(payload, Context())

            # Output result
            print(json.dumps(result))

        except Exception as e:
            error_response = {
                "error": str(e),
                "traceback": traceback.format_exc()
            }
            print(json.dumps(error_response), file=sys.stderr)
            sys.exit(1)

    if __name__ == '__main__':
        main()

  # Node.js Runtime
  Dockerfile.nodejs20: |
    FROM node:20-alpine
    RUN adduser -D func || true
    WORKDIR /app
    COPY runtime-nodejs.js /app/runtime.js
    USER func
    ENTRYPOINT ["node", "/app/runtime.js"]

  runtime-nodejs.js: |
    #!/usr/bin/env node
    /**
     * Function runtime for Node.js 20
     * Reads function code and payload from stdin, executes, outputs result to stdout.
     */

    const vm = require('vm');

    async function main() {
        let input = '';

        // Read all input from stdin
        for await (const chunk of process.stdin) {
            input += chunk;
        }

        try {
            const data = JSON.parse(input);
            const handlerPath = data.handler || 'handler';
            const code = data.code || '';
            const payload = data.payload || {};
            const envVars = data.env || {};

            // Set environment variables
            Object.assign(process.env, envVars);

            // Parse handler
            const parts = handlerPath.split('.');
            const funcName = parts.length > 1 ? parts[parts.length - 1] : handlerPath;

            // Create sandbox with module.exports
            const sandbox = {
                module: { exports: {} },
                exports: {},
                require: require,
                console: console,
                process: process,
                Buffer: Buffer,
                setTimeout: setTimeout,
                setInterval: setInterval,
                clearTimeout: clearTimeout,
                clearInterval: clearInterval,
                Promise: Promise,
            };

            // Execute the code
            vm.runInNewContext(code, sandbox);

            // Get handler from module.exports or exports
            let handler = sandbox.module.exports[funcName] || sandbox.exports[funcName] || sandbox[funcName];

            if (typeof handler !== 'function') {
                throw new Error(`Handler function '${funcName}' not found or not a function`);
            }

            // Execute handler (support async)
            const result = await handler(payload);

            // Output result
            console.log(JSON.stringify(result));

        } catch (error) {
            console.error(JSON.stringify({
                error: error.message,
                stack: error.stack
            }));
            process.exit(1);
        }
    }

    main();

  # Go Runtime
  Dockerfile.go1.24: |
    FROM golang:1.24-alpine AS builder
    WORKDIR /app
    COPY runtime-go.go /app/runtime.go
    RUN go build -tags docker_runtime_go -o runtime runtime.go

    FROM alpine:3.19
    RUN adduser -D func || true
    COPY --from=builder /app/runtime /app/runtime
    USER func
    ENTRYPOINT ["/app/runtime"]

  runtime-go.go: |
    //go:build docker_runtime_go
    // +build docker_runtime_go

    package main

    import (
    	"bytes"
    	"encoding/base64"
    	"encoding/json"
    	"fmt"
    	"io"
    	"os"
    	"os/exec"
    )

    type Input struct {
    	Handler string            `json:"handler"`
    	Code    string            `json:"code"` // base64 encoded binary
    	Payload json.RawMessage   `json:"payload"`
    	Env     map[string]string `json:"env"`
    }

    func main() {
    	// Read input from stdin
    	inputBytes, err := io.ReadAll(os.Stdin)
    	if err != nil {
    		fatal("failed to read stdin: " + err.Error())
    	}

    	var input Input
    	if err := json.Unmarshal(inputBytes, &input); err != nil {
    		fatal("failed to parse input: " + err.Error())
    	}

    	// Set environment variables
    	for key, value := range input.Env {
    		os.Setenv(key, value)
    	}

    	// Decode binary
    	binary, err := base64.StdEncoding.DecodeString(input.Code)
    	if err != nil {
    		fatal("failed to decode binary: " + err.Error())
    	}

    	// Write binary to temp file
    	tmpFile, err := os.CreateTemp("", "handler-*")
    	if err != nil {
    		fatal("failed to create temp file: " + err.Error())
    	}
    	defer os.Remove(tmpFile.Name())

    	if _, err := tmpFile.Write(binary); err != nil {
    		fatal("failed to write binary: " + err.Error())
    	}
    	tmpFile.Close()

    	// Make executable
    	if err := os.Chmod(tmpFile.Name(), 0755); err != nil {
    		fatal("failed to chmod: " + err.Error())
    	}

    	// Execute
    	cmd := exec.Command(tmpFile.Name())
    	cmd.Stdin = bytes.NewReader(input.Payload)
    	cmd.Stderr = os.Stderr

    	output, err := cmd.Output()
    	if err != nil {
    		fatal("execution failed: " + err.Error())
    	}

    	fmt.Print(string(output))
    }

    func fatal(msg string) {
    	fmt.Fprintf(os.Stderr, `{"error":%q}`, msg)
    	os.Exit(1)
    }

  # WASM Runtime
  Dockerfile.wasm: |
    FROM golang:1.24-alpine AS builder
    WORKDIR /app
    COPY runtime-wasm.go /app/runtime.go
    RUN go mod init wasmruntime && \
        go get github.com/tetratelabs/wazero && \
        go build -tags docker_runtime_wasm -o runtime runtime.go

    FROM alpine:3.19
    RUN adduser -D func || true
    COPY --from=builder /app/runtime /app/runtime
    USER func
    ENTRYPOINT ["/app/runtime"]

  runtime-wasm.go: |
    //go:build docker_runtime_wasm
    // +build docker_runtime_wasm

    package main

    import (
    	"context"
    	"encoding/base64"
    	"encoding/json"
    	"fmt"
    	"io"
    	"os"

    	"github.com/tetratelabs/wazero"
    	"github.com/tetratelabs/wazero/api"
    	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
    )

    type Input struct {
    	Handler string            `json:"handler"`
    	Code    string            `json:"code"` // base64 encoded wasm
    	Payload json.RawMessage   `json:"payload"`
    	Env     map[string]string `json:"env"`
    }

    func main() {
    	// Read input from stdin
    	inputBytes, err := io.ReadAll(os.Stdin)
    	if err != nil {
    		fatal("failed to read stdin: " + err.Error())
    	}

    	var input Input
    	if err := json.Unmarshal(inputBytes, &input); err != nil {
    		fatal("failed to parse input: " + err.Error())
    	}

    	// Decode wasm binary
    	wasmBytes, err := base64.StdEncoding.DecodeString(input.Code)
    	if err != nil {
    		fatal("failed to decode wasm: " + err.Error())
    	}

    	// Execute wasm
    	output, err := executeWasm(wasmBytes, input.Payload)
    	if err != nil {
    		fatal("wasm execution failed: " + err.Error())
    	}

    	fmt.Print(string(output))
    }

    func executeWasm(wasmBytes []byte, payload json.RawMessage) ([]byte, error) {
    	ctx := context.Background()

    	runtime := wazero.NewRuntime(ctx)
    	defer runtime.Close(ctx)

    	wasi_snapshot_preview1.MustInstantiate(ctx, runtime)

    	module, err := runtime.CompileModule(ctx, wasmBytes)
    	if err != nil {
    		return nil, fmt.Errorf("compile failed: %w", err)
    	}

    	instance, err := runtime.InstantiateModule(ctx, module, wazero.NewModuleConfig())
    	if err != nil {
    		return nil, fmt.Errorf("instantiate failed: %w", err)
    	}
    	defer instance.Close(ctx)

    	// Get exported functions
    	alloc := instance.ExportedFunction("alloc")
    	handle := instance.ExportedFunction("handle")

    	if alloc == nil || handle == nil {
    		return nil, fmt.Errorf("wasm must export 'alloc' and 'handle' functions")
    	}

    	// Allocate input buffer
    	inputBytes := []byte(payload)
    	results, err := alloc.Call(ctx, uint64(len(inputBytes)))
    	if err != nil {
    		return nil, fmt.Errorf("alloc failed: %w", err)
    	}
    	inputPtr := uint32(results[0])

    	// Write input to memory
    	memory := instance.Memory()
    	if !memory.Write(inputPtr, inputBytes) {
    		return nil, fmt.Errorf("failed to write to memory")
    	}

    	// Call handle
    	results, err = handle.Call(ctx, uint64(inputPtr), uint64(len(inputBytes)))
    	if err != nil {
    		return nil, fmt.Errorf("handle failed: %w", err)
    	}

    	// Parse result
    	packed := results[0]
    	outPtr := uint32(packed >> 32)
    	outLen := uint32(packed & 0xFFFFFFFF)

    	output, ok := memory.Read(outPtr, outLen)
    	if !ok {
    		return nil, fmt.Errorf("failed to read output")
    	}

    	return output, nil
    }

    func fatal(msg string) {
    	fmt.Fprintf(os.Stderr, `{"error":%q}`, msg)
    	os.Exit(1)
    }

    // Ensure api.Module is used (for compilation)
    var _ api.Module
